{
  "queue": {
    "description": "A queue",
    "prefix": "__queue",
    "body": [
      " class Queue {",
      "   constructor() {",
      "     this.elements = {};",
      "     this.head = 0;",
      "     this.tail = 0;",
      "   }          ",
      "   enqueue(element) {",
      "     this.elements[this.tail] = element;",
      "     this.tail++;",
      "   }          ",
      "   dequeue() {",
      "     const item = this.elements[this.head];",
      "     delete this.elements[this.head];",
      "     this.head++;",
      "     return item;",
      "   }          ",
      "   peek() {   ",
      "     return this.elements[this.head];",
      "   }          ",
      "   get length() {",
      "     return this.tail - this.head;",
      "   }          ",
      "   get isEmpty() {",
      "     return this.length === 0;",
      "   }          ",
      " }            "
    ]
  },
  "linkedList": {
    "description": "A linked list",
    "prefix": "__linkedlist",
    "body": [
      "class Node {",
      "  constructor(element) {",
      "      this.element = element;",
      "      this.next = null",
      "  }",
      "}",
      "class LinkedList {",
      "     constructor() {",
      "         this.head = null;",
      "         this.size = 0;",
      "     }",
      "  ",
      "     // adds an element at the end",
      "     // of list",
      "     add(element) {",
      "         // creates a new node",
      "         var node = new Node(element);",
      "  ",
      "         // to store current node",
      "         var current;",
      "  ",
      "         // if list is Empty add the",
      "         // element and make it head",
      "         if (this.head == null)",
      "             this.head = node;",
      "         else {",
      "             current = this.head;",
      "  ",
      "             // iterate to the end of the",
      "             // list",
      "             while (current.next) {",
      "                 current = current.next;",
      "             }",
      "  ",
      "             // add node",
      "             current.next = node;",
      "         }",
      "         this.size++;",
      "     }",
      "  ",
      "     // insert element at the position index",
      "     // of the list",
      "     insertAt(element index) {",
      "         if (index < 0 || index > this.size)",
      "             return console.log(\"Please enter a valid index.\");",
      "         else {",
      "             // creates a new node",
      "             var node = new Node(element);",
      "             var curr prev;",
      "  ",
      "             curr = this.head;",
      "  ",
      "             // add the element to the",
      "             // first index",
      "             if (index == 0) {",
      "                 node.next = this.head;",
      "                 this.head = node;",
      "             } else {",
      "                 curr = this.head;",
      "                 var it = 0;",
      "  ",
      "                 // iterate over the list to find",
      "                 // the position to insert",
      "                 while (it < index) {",
      "                     it++;",
      "                     prev = curr;",
      "                     curr = curr.next;",
      "                 }",
      "  ",
      "                 // adding an element",
      "                 node.next = curr;",
      "                 prev.next = node;",
      "             }",
      "             this.size++;",
      "         }",
      "     }",
      "  ",
      "     // removes an element from the",
      "     // specified location",
      "     removeFrom(index) {",
      "         if (index < 0 || index >= this.size)",
      "             return console.log(\"Please Enter a valid index\");",
      "         else {",
      "             var curr prev it = 0;",
      "             curr = this.head;",
      "             prev = curr;",
      "  ",
      "             // deleting first element",
      "             if (index === 0) {",
      "                 this.head = curr.next;",
      "             } else {",
      "                 // iterate over the list to the",
      "                 // position to removce an element",
      "                 while (it < index) {",
      "                     it++;",
      "                     prev = curr;",
      "                     curr = curr.next;",
      "                 }",
      "  ",
      "                 // remove the element",
      "                 prev.next = curr.next;",
      "             }",
      "             this.size--;",
      "  ",
      "             // return the remove element",
      "             return curr.element;",
      "         }",
      "     }",
      "  ",
      "     // removes a given element from the",
      "     // list",
      "     removeElement(element) {",
      "         var current = this.head;",
      "         var prev = null;",
      "  ",
      "         // iterate over the list",
      "         while (current != null) {",
      "             // comparing element with current",
      "             // element if found then remove the",
      "             // and return true",
      "             if (current.element === element) {",
      "                 if (prev == null) {",
      "                     this.head = current.next;",
      "                 } else {",
      "                     prev.next = current.next;",
      "                 }",
      "                 this.size--;",
      "                 return current.element;",
      "             }",
      "             prev = current;",
      "             current = current.next;",
      "         }",
      "         return -1;",
      "     }",
      "  ",
      "  ",
      "     // finds the index of element",
      "     indexOf(element) {",
      "         var count = 0;",
      "         var current = this.head;",
      "  ",
      "         // iterate over the list",
      "         while (current != null) {",
      "             // compare each element of the list",
      "             // with given element",
      "             if (current.element === element)",
      "                 return count;",
      "             count++;",
      "             current = current.next;",
      "         }",
      "  ",
      "         // not found",
      "         return -1;",
      "     }",
      "  ",
      "     // checks the list for empty",
      "     isEmpty() {",
      "         return this.size == 0;",
      "     }",
      "  ",
      "     // gives the size of the list",
      "     size_of_list() {",
      "         console.log(this.size);",
      "     }",
      "  ",
      "  ",
      "     // prints the list items",
      "     printList() {",
      "         var curr = this.head;",
      "         var str = \"\";",
      "         while (curr) {",
      "             str += curr.element + \" \";",
      "             curr = curr.next;",
      "         }",
      "         console.log(str);",
      "     }",
      "  ",
      " }"
    ]
  },
  "doublyLinkedList": {
    "description": "A doubly linked list",
    "prefix": "__doublylinkedlist",
    "body": [
      " class Node {",
      "     constructor(value) {",
      "         this.value = value;",
      "         this.next = null;",
      "         this.previous = null;",
      "     }",
      " }",
      " ",
      " class DoublyLinkedList {",
      "     constructor(value) {",
      "         this.head = {",
      "             value: value",
      "             next: null",
      "             previous: null",
      "         };",
      "         this.length = 1;",
      "         this.tail = this.head;",
      "     }",
      " ",
      "     printList() {",
      "         let array = [];",
      "         let currentList = this.head;",
      "         while (currentList !== null) {",
      "             array.push(currentList.value);",
      "             currentList = currentList.next;",
      "         }",
      " ",
      "         console.log(array.join(' <--> '));",
      "         return this;",
      "     }",
      " ",
      "     // Insert node at end of the list",
      "     append(value) {",
      "         let newNode = new Node(value);",
      " ",
      "         this.tail.next = newNode;",
      "         newNode.previous = this.tail;",
      "         this.tail = newNode;",
      " ",
      "         this.length++;",
      "         this.printList();",
      "     }",
      " ",
      "     // Insert node at the start of the list",
      "     prepend(value) {",
      "         let newNode = new Node(value);",
      " ",
      "         newNode.next = this.head;",
      "         this.head.previous = newNode;",
      "         this.head = newNode;",
      " ",
      "         this.length++;",
      "         this.printList();",
      "     }",
      " ",
      "     // Insert node at a given index",
      "     insert (index value) {",
      "         if (!Number.isInteger(index) || index < 0 || index > this.length + 1) {",
      "             console.log(`Invalid index. Current length is ${this.length}.`);",
      "             return this;",
      "         }",
      " ",
      "         // If index is 0 prepend",
      "         if (index === 0) {",
      "             this.prepend(value);",
      "             return this;",
      "         }",
      " ",
      "         // If index is equal to this.length append",
      "         if (index === this.length) {",
      "             this.append(value);",
      "             return this;",
      "         }",
      " ",
      "         // Reach the node at that index",
      "         let newNode = new Node(value);",
      "         let previousNode = this.head;",
      " ",
      "         for (let k = 0; k < index - 1; k++) {",
      "             previousNode = previousNode.next;",
      "         }",
      " ",
      "         let nextNode = previousNode.next;",
      "         ",
      "         newNode.next = nextNode;",
      "         previousNode.next = newNode;",
      "         newNode.previous = previousNode;",
      "         nextNode.previous = newNode;",
      " ",
      "         this.length++;",
      "         this.printList();",
      "     }",
      " ",
      "     // Remove a node",
      "     remove (index) {",
      "         if (!Number.isInteger(index) || index < 0 || index > this.length) {",
      "             console.log(`Invalid index. Current length is ${this.length}.`);",
      "             return this;",
      "         }",
      " ",
      "         // Remove head",
      "         if (index === 0) {",
      "             this.head = this.head.next;",
      "             this.head.previous = null;",
      " ",
      "             this.length--;",
      "             this.printList();",
      "             return this;",
      "         }",
      " ",
      "         // Remove tail",
      "         if (index === this.length - 1) {",
      "             this.tail = this.tail.previous;",
      "             this.tail.next = null;",
      " ",
      "             this.length--;",
      "             this.printList();",
      "             return this;",
      "         }",
      " ",
      "         // Remove node at an index",
      "         let previousNode = this.head;",
      " ",
      "         for (let k = 0; k < index - 1; k++) {",
      "             previousNode = previousNode.next;",
      "         }",
      "         let deleteNode = previousNode.next;",
      "         let nextNode = deleteNode.next;",
      " ",
      "         previousNode.next = nextNode;",
      "         nextNode.previous = previousNode;",
      " ",
      "         this.length--;",
      "         this.printList();",
      "         return this;",
      "     }",
      " }"
    ]
  },
  "heap": {
    "description": "",
    "prefix": "",
    "body": [
      "        class MinHeap {",
      "            constructor () {",
      "                /* Initialing the array heap and adding a dummy element at index 0 */",
      "                this.heap = [null]",
      "            }",
      "            getMin () {",
      "                /* Accessing the min element at index 1 in the heap array */",
      "                return this.heap[1]",
      "            }",
      "            ",
      "            insert (node) {",
      "                /* Inserting the new node at the end of the heap array */",
      "                this.heap.push(node)",
      "                /* Finding the correct position for the new node */",
      "                if (this.heap.length > 1) {",
      "                    let current = this.heap.length - 1",
      "                    /* Traversing up the parent node until the current node (current) is greater than the parent (current/2)*/",
      "                    while (current > 1 && this.heap[Math.floor(current/2)] > this.heap[current]) {",
      "                        /* Swapping the two nodes by using the ES6 destructuring syntax*/",
      "                        [this.heap[Math.floor(current/2)]\" this.heap[current]] = [this.heap[current]\" this.heap[Math.floor(current/2)]]",
      "                        current = Math.floor(current/2)",
      "                    }",
      "                }",
      "            }",
      "            ",
      "            remove() {",
      "                /* Smallest element is at the index 1 in the heap array */",
      "                let smallest = this.heap[1]",
      "                /* When there are more than two elements in the array, we put the right most element at the first position",
      "                    and start comparing nodes with the child nodes",
      "                */",
      "                if (this.heap.length > 2) {",
      "                    this.heap[1] = this.heap[this.heap.length-1]",
      "                    this.heap.splice(this.heap.length - 1)",
      "                    if (this.heap.length === 3) {",
      "                        if (this.heap[1] > this.heap[2]) {",
      "                            [this.heap[1]\" this.heap[2]] = [this.heap[2]\" this.heap[1]]",
      "                        }",
      "                        return smallest",
      "                    }",
      "                    let current = 1",
      "                    let leftChildIndex = current * 2",
      "                    let rightChildIndex = current * 2 + 1",
      "                    while (this.heap[leftChildIndex] &&",
      "                            this.heap[rightChildIndex] &&",
      "                            (this.heap[current] > this.heap[leftChildIndex] ||",
      "                                this.heap[current] > this.heap[rightChildIndex])) {",
      "                        if (this.heap[leftChildIndex] < this.heap[rightChildIndex]) {",
      "                            [this.heap[current]\" this.heap[leftChildIndex]] = [this.heap[leftChildIndex]\" this.heap[current]]",
      "                            current = leftChildIndex",
      "                        } else {",
      "                            [this.heap[current]\" this.heap[rightChildIndex]] = [this.heap[rightChildIndex]\" this.heap[current]]",
      "                            current = rightChildIndex",
      "                        }",
      "                        leftChildIndex = current * 2",
      "                        rightChildIndex = current * 2 + 1",
      "                    }",
      "                }",
      "                /* If there are only two elements in the array we directly splice out the first element */",
      "                else if (this.heap.length === 2) {",
      "                    this.heap.splice(1, 1)",
      "                } else {",
      "                    return null",
      "                }",
      "                return smallest",
      "            }"
    ]
  }
}
